	st->unnessesary = 1;
	if (*st->fmt == '#')
		st->hash_flag = ON;
		st->fmt++;
	if (*st->fmt == '-')
		if (st->zero_flag)
			st->zero_flag = 0;
		st->minus_flag = ON;
		st->fmt++;
	if (*st->fmt == '+')
		if (st->plus_flag == ON)
			st->char_count--;
		st->plus_flag = ON;
		st->fmt++;
		st->char_count++;
	if (ft_isalpha(*st->fmt) && st->space_count && !st->plus_flag)
		st->char_count += write(1, " ", 1);
	while (*st->fmt == ' ' && ++st->space_count)
		st->fmt++;
	sub = st->zero;
	sub += (st->width && st->zero_flag) * st->width;
	sub -= (st->va_ret < 0);
	/* if (st->precision && st->zero_flag)
		sub = st->precision; */
		sub = st->width;// - st->len_va_arg + st->len_va_arg;
		sub -= (st->va_ret < 0);
	if (*st->fmt == 'x' || *st->fmt == 'X')
		sub -= (st->hash_flag > 0) * 2;
	/* if (*st->fmt == 'o')
		sub -= (st->hash_flag > 0) * 1; */
	sub -= (st->for_plus > 0 || st->space_count > 0);
	while ((size_t)sub-- > st->len_va_arg)
		st->char_count += write(1, "0", 1);
	if (*st->fmt == '0')
		while (*st->fmt == '0')
			st->fmt++;
		if (!st->minus_flag)
			st->zero_flag = ON;
			st->zero = get_it(st);
	if (st->plus_flag)
		--st->char_count;
	if (*st->fmt == '%' && st->minus_flag == OFF)
		while (++i < st->width)
			st->char_count += write(1, " ", 1);
		st->char_count += write(1, st->fmt, 1);
	else if (*st->fmt == '%' && st->minus_flag == ON)
		st->char_count += write(1, st->fmt, 1);
		while (++i < st->width)
			st->char_count += write(1, " ", 1);
	st->fmt++;
	st->fmt = format;
	st->hold_str = NULL;
		st->char_count = 0;
	st->space_count = 0;
	st->astx_ret = 0;
	st->len_va_arg = 0;
	st->width = 0;
	st->precision = 0;
	st->plus_flag = 0;
	st->minus_flag = 0;
	st->va_ret = 0;
	st->unnessesary = 0;
	st->hash_flag = 0;
	st->zero = 0;
	st->zero_count = 0;
	st->zero_flag = 0;
	st->le_f = 0;
	st->prec_noll = 0;
	st->for_plus = 0;
	st->precision_flag = 0;
	st->char_width = 0;
	st->uint_check = 0;
	st->sign = 1;
	st->float_prec = 6;
		while (FLAGS[i] && FLAGS[i] != *st->fmt)
		if (st->unnessesary)
	while (SPECIF[i] && SPECIF[i] != *st->fmt)
	while (*st->fmt)
		if (*st->fmt != '%')
			st->char_count += write(1, st->fmt++, 1);
		++st->fmt;
		initialize_st(st->fmt, st, 1);
	octet = (unsigned char)va_arg(st->ap, int);
			st->char_count += write(1, "1", 1);
			st->char_count += write(1, "0", 1);
	st->fmt++;
	pf_itoa_base(va_arg(st->ap, long), 16, st);
	st->len_va_arg = ft_strlen(st->hold_str);
	if (st->width)
		st->width -= 2;
	if (st->minus_flag == OFF && st->width)
	st->char_count += write(1, "0x", 2);
	if (*st->hold_str == '0' && st->precision_flag && !st->precision)
		st->fmt++;
		st->char_count += write(1, st->hold_str, ft_strlen(st->hold_str));
	if (st->minus_flag == ON)
	ft_strdel(&st->hold_str);
	st->fmt++;
	sub = st->precision;
	if (st->precision)
		while ((size_t)sub-- > st->len_va_arg)
			st->char_count += write(1, "0", 1);
	sub *= (st->astx_ret);
	if (st->precision && !st->width)
		if (st->precision < st->len_va_arg)
			st->precision = st->len_va_arg;
		sub += st->width - st->precision;
			st->char_count += write(1, " ", 1);
	else if (st->width)
		sub += st->width;
		while ((size_t)sub-- > st->len_va_arg)
			st->char_count += write(1, " ", 1);
	if (st->precision && st->precision < st->len_va_arg)
		st->len_va_arg = st->precision;
	if (!st->minus_flag)
	if (!st->precision && st->precision_flag)
		st->char_count += write(1, "", 0);
		st->char_count += write(1, st->hold_str, st->len_va_arg);
	if (st->minus_flag)
	st->hold_str = va_arg(st->ap, char *);
	if (st->hold_str == NULL)
		st->hold_str = "(null)";
	st->len_va_arg = ft_strlen(st->hold_str);
	if ((!st->precision && st->precision_flag) && st->width)
		while (st->width)
			st->char_count += write(1, " ", 1);
			st->width--;
		st->fmt++;
	st->fmt++;
	st->char_width = 1;
	if (st->minus_flag == OFF && st->width)
	ft_putchar((char)va_arg(st->ap, int));
	++st->char_count;
	if (st->minus_flag == ON)
	st->fmt++;
		new_unit = ft_atoi(st->hold_str);
		ft_strdel(&st->hold_str);
		pf_itoa_base(new_unit + st->sign, 10, st);
		res = ((last_digit + 1 * st->sign) % 2 == 0);
	combo = ft_strnew(ft_strlen(st->hold_str) + ft_strlen(mantissa) + 1); // this might be taken away
	while (st->hold_str[i])
		combo[j++] = st->hold_str[i++];
	if (st->precision || x == 6)
	ft_strdel(&st->hold_str);
	mantissa = ft_strnew(st->float_prec);
	while (st->float_prec > x)
		st->sign = -1;
		st->char_count += write(1, "-", 1);
		if (st->width)  //this puts minus in wrong place if -flag
			st->width--;
		st->char_count += write(1, "-", 1);
	if (!st->precision && st->prec_noll)
		round_up = bankers_rounding(nbr, last_digit + 48, st) * st->sign;
		st->hold_str = ft_strdup(float_str);
	if (*st->fmt == 'x' || *st->fmt == 'X')
		pf_itoa_base((unsigned int)va_arg(st->ap, long long), 16, st);
	else if (*st->fmt == 'h' && (st->fmt[i] == 'x' || st->fmt[i] == 'X'))
		++st->fmt;
		pf_itoa_base((unsigned short)va_arg(st->ap, long long), 16, st);
	else if (*st->fmt == 'l' && (st->fmt[i] == 'x' || st->fmt[i] == 'X'))
		++st->fmt;
		pf_itoa_base(va_arg(st->ap, unsigned long), 16, st);
	else if (*st->fmt == 'h' && st->fmt[i] == 'h' \
		&& (st->fmt[i + 1] == 'x' || st->fmt[i + 1] == 'X'))
		st->fmt += 2;
		pf_itoa_base((unsigned char)va_arg(st->ap, long long), 16, st);
	else if (*st->fmt == 'l' && st->fmt[i] == 'l' \
		&& (st->fmt[i + 1] == 'x' || st->fmt[i + 1] == 'X'))
		st->fmt += 2;
		pf_itoa_base(va_arg(st->ap, long long), 16, st);
	if (*st->fmt == 'x')
		st->char_count += write(1, "0x", 2);
		st->char_count += write(1, "0X", 2);
	if (*st->hold_str == '-')
		if (st->plus_flag && !st->minus_flag && --st->char_count)
			st->plus_flag = OFF;
		st->hold_str++;
	else if (st->plus_flag)
		st->for_plus = ON;
		st->plus_flag = OFF;
/* 	if (st->hash_flag && *st->hold_str != '0' && !st->width) //!widht is that correct?
	if (*st->hold_str == '0' && st->precision_flag && !st->precision)
		st->char_count += write(1, st->hold_str, ft_strlen(st->hold_str));
	if (st->minus_flag)
	st->width -= 2 * (st->hash_flag && st->width && (*st->fmt == 'x' || *st->fmt == 'X'));
	ft_strdel(&st->hold_str);
	st->fmt++;
	if (*st->fmt == '*')
		st->astx_ret = va_arg(st->ap, int);
		st->fmt++;
	else if (st->astx_ret)
		sub = st->astx_ret;
		if (st->plus_flag == ON)
		while (sub-- > st->len_va_arg)
			st->char_count += write(1, " ", 1);
	if (*st->fmt == 'd' || *st->fmt == 'i')
		st->hold_str = conv_to_str((int)va_arg(st->ap, long long), st);
	else if (*st->fmt == 'h' && (st->fmt[i] == 'd' || st->fmt[i] == 'i'))
		++st->fmt;
		st->hold_str = conv_to_str((short)va_arg(st->ap, long long), st);
	else if (*st->fmt == 'l' && (st->fmt[i] == 'd' || st->fmt[i] == 'i'))
		++st->fmt;
		st->hold_str = conv_to_str((long)va_arg(st->ap, long long), st);
	else if (*st->fmt == 'h' && st->fmt[i] == 'h' \
		&& (st->fmt[i + 1] == 'd' || st->fmt[i + 1] == 'i'))
		st->fmt += 2;
		st->hold_str = conv_to_str((char)va_arg(st->ap, long long), st);
	else if (*st->fmt == 'l' && st->fmt[i] == 'l' \
		&& (st->fmt[i + 1] == 'd' || st->fmt[i + 1] == 'i'))
		st->fmt += 2;
		st->hold_str = conv_to_str(va_arg(st->ap, long long), st);
	if (*st->hold_str == '-')
		if (st->plus_flag && !st->minus_flag && --st->char_count)
			st->plus_flag = OFF;
		st->hold_str++;
	else if (st->plus_flag)
		st->for_plus = ON;
		st->plus_flag = OFF;
	if (st->for_plus)
	if (*st->hold_str == '0' && st->precision_flag && !st->precision)
		st->char_count += write(1, st->hold_str, ft_strlen(st->hold_str));
	if (st->minus_flag)
	st->va_ret = nbr;
	if (st->va_ret < 0)
	if (*--st->hold_str == '-')
		ft_strdel(&st->hold_str);
		++st->hold_str;
		ft_strdel(&st->hold_str);
	st->fmt++;
	st->unnessesary = 1;
	if (*st->hold_str == '-')
		if (st->plus_flag && !st->minus_flag && --st->char_count)
			st->plus_flag = OFF;
		st->hold_str++;
	else if (st->plus_flag)
		st->for_plus = ON;
		st->plus_flag = OFF;
	if (st->for_plus)
	st->char_count += write(1, st->hold_str, ft_strlen(st->hold_str));
	if (st->minus_flag)
	if (st->prec_noll)
		st->float_prec = st->precision;
	if (st->le_f)
		conv_float_str(va_arg(st->ap, long double), st);
		conv_float_str(va_arg(st->ap, double), st);
	ft_strdel(&st->hold_str);
	st->fmt++;
	if (*st->fmt == 'o')
		pf_itoa_base((unsigned int)va_arg(st->ap, long long), 8, st);
	else if (*st->fmt == 'h' && st->fmt[i] == 'o')
		++st->fmt;
		pf_itoa_base((unsigned short)va_arg(st->ap, long long), 8, st);
	else if (*st->fmt == 'l' && st->fmt[i] == 'o')
		++st->fmt;
		pf_itoa_base((long)va_arg(st->ap, long long), 8, st);
	else if (*st->fmt == 'h' && st->fmt[i] == 'h' && st->fmt[i + 1] == 'o')
		st->fmt += 2;
		pf_itoa_base((unsigned char)va_arg(st->ap, long long), 8, st);
	else if (*st->fmt == 'l' && st->fmt[i] == 'l' && st->fmt[i + 1] == 'o')
		st->fmt += 2;
		pf_itoa_base(va_arg(st->ap, long long), 8, st);
	//st->len_va_arg += (st->hash_flag && *st->fmt == 'o');
	if (*st->hold_str == '0' && st->precision_flag && !st->precision \
		&& !st->hash_flag && st->fmt++)
		st->char_count += write(1, st->hold_str, ft_strlen(st->hold_str));
	if (st->minus_flag == ON)
	ft_strdel(&st->hold_str);
	st->fmt++;
	if (*st->fmt == 'u')
		st->hold_str = \
			uint_str((unsigned int)va_arg(st->ap, unsigned long long), st);
	else if (*st->fmt == 'h' && st->fmt[i] == 'u')
		++st->fmt;
		st->hold_str = \
			uint_str((unsigned short)va_arg(st->ap, unsigned long long), st);
	else if (*st->fmt == 'l' && st->fmt[i] == 'u')
		++st->fmt;
		st->hold_str = \
			uint_str((unsigned long)va_arg(st->ap, unsigned long long), st);
	else if (*st->fmt == 'h' && st->fmt[i] == 'h' && st->fmt[i + 1] == 'u')
		st->fmt += 2;
		st->hold_str = \
			uint_str((unsigned char)va_arg(st->ap, unsigned long long), st);
	else if (*st->fmt == 'l' && st->fmt[i] == 'l' && st->fmt[i + 1] == 'u')
		st->fmt += 2;
		st->hold_str = uint_str(va_arg(st->ap, unsigned long long), st);
	else if (*st->fmt == 'L' || (*st->fmt == 'l' && st->fmt[i] == 'f'))
		++st->fmt;
		st->le_f = ON;
	if (st->plus_flag == ON)
		st->char_count--;
	if (*st->hold_str == '0' && st->precision_flag && !st->precision)
		st->char_count += write(1, st->hold_str, ft_strlen(st->hold_str));
	if (st->minus_flag == ON)
	ft_strdel(&st->hold_str);
	st->va_u_ret = nbr;
	st->uint_check = ON;
	st->fmt++;
	st->hold_str = (char *)ft_strnew(l);
	if (!st->hold_str)
		if ((*st->fmt == 'x' || *st->fmt == 'p') && nbr % base > 9)
			st->hold_str[l] = (char)(nbr % base) + 87;
		else if (*st->fmt == 'X' && nbr % base > 9)
			st->hold_str[l] = (char)(nbr % base) + 55;
			st->hold_str[l] = (char)(nbr % base) + 48;
	st->len_va_arg = ft_strlen(st->hold_str);
	st->len_va_arg += (st->hash_flag && *st->fmt == 'o');
	//st->len_va_arg += 2 * (st->hash_flag && (*st->fmt == 'x' || *st->fmt == 'X'));
	if (!st->minus_flag && st->width && !st->zero_flag)
	if (st->va_ret >= 0)
		if (!st->uint_check && ft_isalpha(*st->fmt) && st->space_count && !st->plus_flag) //not correct check?
		/* if (st->zero_flag &&)
		if (st->hash_flag && *st->hold_str != '0' && (*st->fmt == 'x' || *st->fmt == 'X'))
		if (st->hash_flag && *st->hold_str != '0' && *st->fmt == 'o')// && st->len_va_arg++)
			st->char_count += write(1, "0", 1);
		if (st->precision_flag)
		if (!st->plus_flag && st->zero_flag && !st->precision_flag)
	if (*st->hold_str == '-')
		st->char_count += write(1, "-", 1);
	++st->prec_noll;
	while (ft_isdigit(*st->fmt) && ++c_single)
			ret = *st->fmt - 48;
			ret = ret * 10 + (*st->fmt - 48);
		st->fmt++;
	if (*st->fmt == '.')
		if (st->zero_flag) //new test (zero flag ignored with precision on %d)
			st->zero_flag = 0;
			st->width = st->zero;
			st->zero = 0;
		st->fmt++;
		st->precision_flag = 1;
		st->precision = get_it(st);
	if (ft_isdigit(*st->fmt ) && (st->zero_flag == OFF || st->prec_noll == ON))
		st->width = get_it(st);
	sub = st->precision;
	st->len_va_arg -= (st->va_ret < 0);
	//st->precision -= (st->hash_flag && *st->fmt == 'o');
	//st->precision -= 2 * (st->hash_flag && (*st->fmt == 'x' || *st->fmt == 'X'));
	if (st->precision && !st->plus_flag)
		/* if (st->zero_flag) // wrong, zero glaf ignores when precision
			sub =  st->zero - st->precision;
			sub *= (st->va_ret >= 0 && st->precision < st->zero);
				st->char_count += write(1, " ", 1);
			sub *= (st->zero < st->precision && st->va_ret >= 0 && st->precision < st->zero);
		while ((size_t)sub-- > st->len_va_arg)
			st->char_count += write(1, "0", 1);
	sub *= (st->astx_ret);
	if (st->precision)
		if (st->precision < st->len_va_arg)
			st->precision = st->len_va_arg;
		sub += st->width - st->precision;
		sub -= (st->va_ret < 0 || st->plus_flag || st->space_count || (st->minus_flag  && st->for_plus)); //|| st->minus_flag);
			st->char_count += write(1, " ", 1);
		sub -= ((st->for_plus && --st->char_count) || (st->minus_flag && st->va_ret < 0));//last party right?
		sub += (st->precision_flag && !st->precision);
		sub -= (st->plus_flag || st->space_count || st->char_width);
		sub += st->width;
		if (*st->fmt == 'f' && (st->precision_flag && !st->precision))
		while ((size_t)sub-- > st->len_va_arg)
			st->char_count += write(1, " ", 1);
