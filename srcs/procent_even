	pf_itoa_base(va_arg(st->ap, long), 16, st);
	st->len_va_arg = ft_strlen(st->hold_str);
	if (st->width)
		st->width -= 2;
	if (st->minus_flag == OFF && st->width)
	st->char_count += write(1, "0x", 2);
	if (*st->hold_str == '0' && st->precision_zero && !st->precision)
		st->fmt++;
		st->char_count += write(1, st->hold_str, ft_strlen(st->hold_str));
	if (st->minus_flag == ON)
	ft_strdel(&st->hold_str);
	st->fmt++;
	if (*st->fmt == '*')
		st->astx_ret = va_arg(st->ap, int);
		st->fmt++;
	else if (st->astx_ret)
		sub = st->astx_ret;
		if (st->plus_flag == ON)
		while (sub-- > st->len_va_arg)
			st->char_count += write(1, " ", 1);
	octet = (unsigned char)va_arg(st->ap, int);
			st->char_count += write(1, "1", 1);
			st->char_count += write(1, "0", 1);
	st->fmt++;
	st->char_width = 1;
	if (st->minus_flag == OFF && st->width)
	ft_putchar((char)va_arg(st->ap, int));
	++st->char_count;
	if (st->minus_flag == ON)
	st->fmt++;
	if (*st->fmt == 'd' || *st->fmt == 'i')
		st->hold_str = conv_to_str((int)va_arg(st->ap, long long), st);
	else if (*st->fmt == 'h' && (st->fmt[i] == 'd' || st->fmt[i] == 'i'))
		++st->fmt;
		st->hold_str = conv_to_str((short)va_arg(st->ap, long long), st);
	else if (*st->fmt == 'l' && (st->fmt[i] == 'd' || st->fmt[i] == 'i'))
		++st->fmt;
		st->hold_str = conv_to_str((long)va_arg(st->ap, long long), st);
	else if (*st->fmt == 'h' && st->fmt[i] == 'h' \
		&& (st->fmt[i + 1] == 'd' || st->fmt[i + 1] == 'i'))
		st->fmt += 2;
		st->hold_str = conv_to_str((char)va_arg(st->ap, long long), st);
	else if (*st->fmt == 'l' && st->fmt[i] == 'l' \
		&& (st->fmt[i + 1] == 'd' || st->fmt[i + 1] == 'i'))
		st->fmt += 2;
		st->hold_str = conv_to_str(va_arg(st->ap, long long), st);
	if (*st->fmt == 'u')
		st->hold_str = \
			uint_str((unsigned int)va_arg(st->ap, unsigned long long), st);
	else if (*st->fmt == 'h' && st->fmt[i] == 'u')
		++st->fmt;
		st->hold_str = \
			uint_str((unsigned short)va_arg(st->ap, unsigned long long), st);
	else if (*st->fmt == 'l' && st->fmt[i] == 'u')
		++st->fmt;
		st->hold_str = \
			uint_str((unsigned long)va_arg(st->ap, unsigned long long), st);
	else if (*st->fmt == 'h' && st->fmt[i] == 'h' && st->fmt[i + 1] == 'u')
		st->fmt += 2;
		st->hold_str = \
			uint_str((unsigned char)va_arg(st->ap, unsigned long long), st);
	else if (*st->fmt == 'l' && st->fmt[i] == 'l' && st->fmt[i + 1] == 'u')
		st->fmt += 2;
		st->hold_str = uint_str(va_arg(st->ap, unsigned long long), st);
	else if (*st->fmt == 'L' || (*st->fmt == 'l' && st->fmt[i] == 'f')) // is this correct?
		++st->fmt;
		st->le_f = ON;
	if (*st->fmt == 'x' || *st->fmt == 'X')
		pf_itoa_base((unsigned int)va_arg(st->ap, long long), 16, st);
	else if (*st->fmt == 'h' && (st->fmt[i] == 'x' || st->fmt[i] == 'X'))
		++st->fmt;
		pf_itoa_base((unsigned short)va_arg(st->ap, long long), 16, st);
	else if (*st->fmt == 'l' && (st->fmt[i] == 'x' || st->fmt[i] == 'X'))
		++st->fmt;
		pf_itoa_base(va_arg(st->ap, unsigned long), 16, st);
	else if (*st->fmt == 'h' && st->fmt[i] == 'h' \
		&& (st->fmt[i + 1] == 'x' || st->fmt[i + 1] == 'X'))
		st->fmt += 2;
		pf_itoa_base((unsigned char)va_arg(st->ap, long long), 16, st);
	else if (*st->fmt == 'l' && st->fmt[i] == 'l' \
		&& (st->fmt[i + 1] == 'x' || st->fmt[i + 1] == 'X'))
		st->fmt += 2;
		pf_itoa_base(va_arg(st->ap, long long), 16, st);
	++st->prec_noll;
	while (ft_isdigit(*st->fmt) && ++c_single)
			ret = *st->fmt - 48;
			ret = ret * 10 + (*st->fmt - 48);
		st->fmt++;
	if (*st->fmt == '.')
		st->fmt++;
		st->precision_zero = 1;
		st->precision = get_it(st);
	if (ft_isdigit(*st->fmt ) && (st->zero_flag == OFF || st->prec_noll == ON))
		st->width = get_it(st);
	sum = st->precision;
	st->len_va_arg -= (st->va_ret < 0);
	if (st->precision && st->plus_flag == OFF)
			if (st->zero_flag == ON)
				sub =  st->zero - st->precision;	//ft_imax(st->precision, st->zero) - ft_imin(st->precision, st->zero);
				sub *= (st->va_ret >= 0 && st->precision < st->zero);
					st->char_count += write(1, " ", 1);
				sum *= (st->zero < st->precision && st->va_ret >= 0 && st->precision < st->zero);
			while ((size_t)sum-- > st->len_va_arg)
				st->char_count += write(1, "0", 1);
	if (st->astx_ret)
		sub = st->astx_ret;
	if (st->precision)
		if (st->precision < st->len_va_arg)
			st->precision = st->len_va_arg;
			st->precision -= (st->va_ret < 0);
		sub += st->width - st->precision;
		sub -= (st->va_ret < 0 || st->plus_flag || st->space_count || (st->minus_flag  && st->for_plus)); //|| st->minus_flag);
			st->char_count += write(1, " ", 1);
		if (st->for_plus && --st->char_count)
		if (st->minus_flag && st->va_ret < 0)
		sub += (st->precision_zero && !st->precision);
		sub -= (st->plus_flag || st->space_count || st->char_width);// || st->minus_flag);st->va_ret < 0 || 
		sub += st->width;
		//sub -= (st->minus_flag > 0);
		while ((size_t)sub-- > st->len_va_arg)
			st->char_count += write(1, " ", 1);
	st->unnessesary = 1;
	if (*st->fmt == '#')
		st->hash_flag = ON;
		st->fmt++;
	if (*st->fmt == '-')
		st->minus_flag = ON;
		st->fmt++;
	if (*st->fmt == '+')
		if (st->plus_flag == ON)
			st->char_count--;
		st->plus_flag = ON;
		st->fmt++;
		st->char_count++;
	if (ft_isalpha(*st->fmt) && st->space_count && !st->plus_flag)
		st->char_count += write(1, " ", 1);
	while (*st->fmt == ' ' && ++st->space_count)
		st->fmt++;
	sub = st->zero;
	sub -= (st->va_ret < 0);
	if (st->precision && st->zero_flag == ON)
		sub = st->precision;
	if (st->width && st->zero_flag == ON)
		sub = st->width - st->len_va_arg + st->len_va_arg;
		sub -= (st->va_ret < 0);
	if (*st->fmt == 'x' || *st->fmt == 'x')
		sub -= (st->hash_flag > 0) * 2;
	if (*st->fmt == 'o')
		sub -= (st->hash_flag > 0) * 1;
	sub -= (st->for_plus > 0 || st->space_count > 0);
	while ((size_t)sub-- > st->len_va_arg)
		st->char_count += write(1, "0", 1);
	if (*st->fmt == '0')
		while (*st->fmt == '0')
			st->fmt++;
		if (!st->minus_flag)
			st->zero_flag = ON;
			st->zero = get_it(st);
	if (st->plus_flag)
		--st->char_count;
	if (*st->fmt == '%' && st->minus_flag == OFF)
		while (++i < st->width)
			st->char_count += write(1, " ", 1);
		st->char_count += write(1, st->fmt, 1);
	else if (*st->fmt == '%' && st->minus_flag == ON)
		st->char_count += write(1, st->fmt, 1);
		while (++i < st->width)
			st->char_count += write(1, " ", 1);
	st->fmt++;
		new_unit = ft_atoi(st->hold_str);
		ft_strdel(&st->hold_str);
		pf_itoa_base(new_unit + st->sign, 10, st);
		res = ((last_digit + 1 * st->sign) % 2 == 0);
	combo = ft_strnew(ft_strlen(st->hold_str) + ft_strlen(mantissa) + 1); // this might be taken away
	while (st->hold_str[i])
		combo[j++] = st->hold_str[i++];
	if (st->precision || x == 6)
	ft_strdel(&st->hold_str);
		st->sign = -1;
		st->char_count += write(1, "-", 1);
		st->char_count += write(1, "-", 1);
	if (!st->precision && st->prec_noll)
		round_up = bankers_rounding(nbr, last_digit + 48, st) * st->sign;
		st->hold_str = ft_strdup(float_str);
	if (st->prec_noll)
		flag = st->precision;
	if (st->le_f == ON)
		conv_float_str(va_arg(st->ap, long double), flag, st);
		conv_float_str(va_arg(st->ap, double), flag, st);
	st->char_count += write(1, st->hold_str, ft_strlen(st->hold_str));
	ft_strdel(&st->hold_str);
	st->fmt++;
	st->fmt = format;
		st->char_count = 0;
	st->space_count = 0;
	st->astx_ret = 0;
	st->len_va_arg = 0;
	st->width = 0;
	st->precision = 0;
	st->plus_flag = OFF;
	st->minus_flag = OFF;
	st->va_ret = 0;
	st->unnessesary = 0;
	st->hash_flag = OFF;
	st->zero = 0;
	st->zero_count = 0;
	st->zero_flag = OFF;
	st->hold_str = NULL;
	st->le_f = OFF;
	st->prec_noll = 0;
	st->for_plus = OFF;
	st->precision_zero = 0;
	st->char_width = 0;
	st->uint_check = OFF;
	st->sign = 1;
	if (*st->fmt == 'x')
		st->char_count += write(1, "0x", 2);
		st->char_count += write(1, "0X", 2);
	if (*st->hold_str == '-')
		if (st->plus_flag == ON && st->minus_flag == OFF && --st->char_count)
			st->plus_flag = OFF;
		st->hold_str++;
	else if (st->plus_flag == ON)
		st->for_plus = ON;
		st->plus_flag = OFF;
	if (st->hash_flag == ON && *st->hold_str != '0' && st->width)
	if (*st->hold_str == '0' && st->precision_zero && !st->precision)
		st->char_count += write(1, st->hold_str, ft_strlen(st->hold_str));
	if (st->minus_flag == ON)
	st->hold_str = (char *)ft_strnew(l);
	if (!st->hold_str)
		if ((*st->fmt == 'x' || *st->fmt == 'p') && nbr % base > 9)
			st->hold_str[l] = (char)(nbr % base) + 87;
		else if (*st->fmt == 'X' && nbr % base > 9)
			st->hold_str[l] = (char)(nbr % base) + 55;
			st->hold_str[l] = (char)(nbr % base) + 48;
	if (st->hash_flag && st->width)
		st->width -= 2;
	if (st->precision && st->zero_flag)
		st->precision += 2;
	ft_strdel(&st->hold_str);
	st->fmt++;
	if (*st->hold_str == '-')
		if (st->plus_flag == ON && st->minus_flag == OFF && --st->char_count)
			st->plus_flag = OFF;
		st->hold_str++;
	else if (st->plus_flag == ON)
		st->for_plus = ON;
		st->plus_flag = OFF;
	if (st->for_plus == ON)
	if (*st->hold_str == '0' && st->precision_zero && !st->precision)
		st->char_count += write(1, st->hold_str, ft_strlen(st->hold_str));
	if (st->minus_flag == ON)
	st->va_ret = nbr;
	if (st->va_ret < 0)
	st->len_va_arg = ft_strlen(st->hold_str);
	if (st->minus_flag == OFF && st->width && !st->zero_flag)
	if (st->va_ret >= 0)
		if (!st->uint_check)
		if (st->zero_flag)
		if (st->hash_flag == ON && *st->hold_str != '0' && !st->width && (*st->fmt == 'x' || *st->fmt == 'X'))
		if (st->hash_flag == ON && *st->hold_str != '0' && !st->width && *st->fmt == 'o')
			st->char_count += write(1, "0", 1);
		if (!st->zero_flag)
		if (!st->plus_flag)
	if (*st->hold_str == '-')
		st->char_count += write(1, "-", 1);
	if (*--st->hold_str == '-')
		ft_strdel(&st->hold_str);
		++st->hold_str;
		ft_strdel(&st->hold_str);
	st->fmt++;
	st->unnessesary = 1;
	if (*st->fmt == 'o')
		pf_itoa_base((unsigned int)va_arg(st->ap, long long), 8, st);
	else if (*st->fmt == 'h' && st->fmt[i] == 'o')
		++st->fmt;
		pf_itoa_base((unsigned short)va_arg(st->ap, long long), 8, st);
	else if (*st->fmt == 'l' && st->fmt[i] == 'o')
		++st->fmt;
		pf_itoa_base((long)va_arg(st->ap, long long), 8, st);
	else if (*st->fmt == 'h' && st->fmt[i] == 'h' && st->fmt[i + 1] == 'o')
		st->fmt += 2;
		pf_itoa_base((unsigned char)va_arg(st->ap, long long), 8, st);
	else if (*st->fmt == 'l' && st->fmt[i] == 'l' && st->fmt[i + 1] == 'o')
		st->fmt += 2;
		pf_itoa_base(va_arg(st->ap, long long), 8, st);
	st->width -= (st->hash_flag && st->width);
	if (st->hash_flag == ON && st->width)
		st->char_count += write(1, "0", 1);
	if (*st->hold_str == '0' && st->precision_zero && !st->precision \
		&& !st->hash_flag && st->fmt++)
		st->char_count += write(1, st->hold_str, ft_strlen(st->hold_str));
	if (st->minus_flag == ON)
	ft_strdel(&st->hold_str);
	st->fmt++;
		while (FLAGS[i] && FLAGS[i] != *st->fmt)
		if (st->unnessesary == 1)
	while (SPECIF[i] && SPECIF[i] != *st->fmt)
	while (*st->fmt)
		if (*st->fmt != '%')
			st->char_count += write(1, st->fmt++, 1);
		++st->fmt;
		initialize_st(st->fmt, st, 1);
	len = st->len_va_arg;
	if (st->precision && st->precision < st->len_va_arg)
		st->len_va_arg = st->precision;
	if (st->minus_flag == OFF && st->width)
	if (!len && st->width)
		while (len++ < st->precision)
			st->char_count += write(1, " ", 1);
			st->char_count += write(1, st->hold_str, len);
			st->char_count += write(1, st->hold_str, st->len_va_arg);
	if (st->minus_flag == ON)
	st->hold_str = va_arg(st->ap, char *);
	if (st->hold_str == NULL && st->fmt++)
		st->char_count += write(1, "(null)", 6);
	st->len_va_arg = ft_strlen(st->hold_str);
	st->fmt++;
	if (st->plus_flag == ON)
		st->char_count--;
	if (*st->hold_str == '0' && st->precision_zero && !st->precision)
		st->char_count += write(1, st->hold_str, ft_strlen(st->hold_str));
	if (st->minus_flag == ON)
	ft_strdel(&st->hold_str);
	st->va_u_ret = nbr;
	st->uint_check = ON;
	st->fmt++;
